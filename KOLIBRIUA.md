![Логотип Колібрі](logo.png)

# Мова програмування Kolibri (альфа 0.1)

## Опис

**Колібрі** - це мультипарадигмальна мова програмування, яка поєднує можливості різних мов для легкого та потужного кодування. Високо оптимізована завдяки використанню C++ для проміжної компіляції, вона також дозволяє безпосередньо керувати пам'яттю. Керування пам'яттю суворо регулюється системою "диктаторських вказівників". 

Kolibri підтримує процедурну, функціональну та об'єктно-орієнтовану парадигми програмування. Він автоматично визначає типи змінних, спрощуючи синтаксис і усуваючи такі проблеми, як `nullptr` та неініціалізовані змінні. Синтаксис Kolibri розроблено для максимальної стислості та читабельності.

---

## <span style="color:red">Відмова від відповідальності</span>

**АЛЬФА-ВЕРСІЯ 0.1**: У поточній версії не вистачає більшості запланованих у майбутньому функцій, таких як класи, царства, лямбди, стандартні функції тощо. Компілятор також має значні проблеми. Щоб повідомити про помилки або зробити внесок у проект, будь ласка, напишіть нам на [latestback@gmail.com](mailto:latestback@gmail.com).

## Структура програми

### Головний файл: `.lbo'

Наріжним каменем програми Kolibri є файл `.lbo` (LittleBird Object). Цей файл слугує точкою входу та орієнтиром для всієї програми. Всі виконувані файли `.lb` розташовуються відносно цього файлу `.lbo` в папці `source`.

#### Структура файлів у файлі `.lbo'

- **Головний файл**: Вказує на основний файл `.lb`.
- **Допоміжні файли**: Вказує на інші `.lb`-файли (необов'язково, допускається декілька)
- **lib**: Вказує на бібліотеки (необов'язково, допускається декілька)

```text
main.lb
second.lb
lib
C:\LB\lib.lbc
```

### Виконувані файли: `.lb`

Виконувані файли з розширенням `.lb` містять власне код і пов'язані з головним файлом `.lbo`.

#### Вбудована головна функція

Головний файл `.lb` має вбудовану функцію `Main(args:[string])`. Вона слугує точкою входу для виконання програми. Функція працює доти, доки не буде визначено простір імен, дату або клас.

**Приклад: Рекурсивна функція main**

```c#
if args[0]::long == 0 || args[0]::long == 1: => 1;
=> Main([(args[0]::long - 1)::string])::long * args[0]::long;
```

### Бібліотеки: `.lbc'

Бібліотеки Kolibri використовують розширення `.lbc` (LittleBird Compiled) і можуть бути вказані у файлі `.lbo` у розділі `Lib`.

### Запуск програми

Для компіляції та запуску програми:

1. Клацаєм ПКМ по `.lbo`
2. Вибираємо пункт `Властивості`
3. Навпроти `Застосунок` клацаємо на `Змінити...`
4. Змінюємо на компілятор `Kolibri` (якщо немає в стандартних програмах, то вибираємо вручну)
5. Запускаємо

Виконавчий файл компілюється в папці з `.lbo`

## Створення змінних та незмінність

У програмуванні змінна - це, по суті, скринька для зберігання даних. Ви можете думати про неї як про контейнер, куди ви кладете речі (значення), які вам можуть знадобитися пізніше. Kolibri спрощує процес створення змінних за допомогою свого синтаксису.

### Оголошення змінної

У Kolibri змінна оголошується за допомогою синтаксису `ім'я = вираз;`. Ім'я може починатися з символу підкреслення (`_`), далі йдуть англійські літери та цифри (не як перший символ). Компілятор визначає тип змінної, аналізуючи вираз.

**Приклад**: 
```c#
count = 10;
```

Якщо змінна з таким іменем вже існує, синтаксис `ім'я = вираз;` не створить нову змінну, а змінить її значення.

**Приклад**:
```c#
count = 20; // Тепер count дорівнює 20, а не 10
```

Якщо тип нового виразу не співпадає з типом існуючої змінної, відбудеться помилка, а не зміна типу.

**Приклад**:
```c#
count = "ten"; // Виникне помилка
```

### Незмінність

Існують сценарії, коли вам потрібно, щоб змінна залишалася незмінною протягом свого життя. Зверніть увагу, що вона відрізняється від константи; це більше схоже на блокуванн на переприсвоєння на рівні компілятора.

Щоб оголосити незмінну змінну, використовуйте синтаксис `=ім'я = вираз;`.

**Приклад**:

```c#
=answerToTheUltimateQuestionOfLifeTheUniverseAndEverything = 42; // Цю змінну не можна змінювати
```

## Типи даних та літерали

Типи даних визначають природу і тип даних, які можуть зберігатися у змінній. Літерали - це константні значення, які використовуються для представлення цих типів у виразах. Нижче наведено повну таблицю типів даних, доступних в Kolibri, їх літералів та розмірів зберігання.

| Тип даних | Літерали          | Розмір  | Опис
|-----------|-------------------|---------|----------------------|
| `bool`    | `true` \| `false` | 1 байт | Логічний тип
| `byte`    | `34b`             | 1 байт | Цілий тип
| `short`   | `54s`             | 2 байти | Цілий тип | 
| `int`     | `42i`             | 4 байти | Цілий тип | 
| `long`    | `64`              | 8 байт | Цілий тип |
| `extra`   | `42e`             | 16 байт | Цілий тип | 
| `float`   | `43f` \| `.1f` \| `1.1f` | 4 байти | Тип з плаваючою комою
| `double`  | `.1` \| `1.1` | 8 байт | Тип з плаваючою комою
| `quad`    | `43q` \| `.1q` \| `1.1q` | 16 байт | Тип з плаваючою комою
| `string`  | `"Hello, World!"` | 2 байти на символ | Рядковий тип Unicode

## Стандартний ввід та вивід

Взаємодія з консоллю є фундаментальною частиною програмування, і Kolibri надає декілька вбудованих методів для введення та виведення даних. Нижче наведено основні функції вводу/виводу:

### Методи виводу

- **`console.Write(a:string)`**: Виводить рядок `a` на консоль в лінію, без додавання нового рядка в кінці.

- **`console.WriteLine(a:string)`**: Виводить рядок `a` в консоль і додає новий рядок в кінці, переводячи курсор на наступний рядок.

### Методи вводу

- **`console.Read()`**: Читає ввід з консолі до тих пір, поки не зустрінеться пробіл або символ нового рядка. Перехоплений ввід повертається у вигляді рядка.

- **`console.Read(a:string)`**: Спочатку виводить на консоль рядок `a`, а потім читає наступний ввід, доки не зустрінеться пробіл або символ переведення рядка. Перехоплений ввід повертається у вигляді рядка.

Використовуючи ці методи, ви можете створювати інтерактивні програми, які можуть як виводити інформацію користувачеві, так і перехоплювати ввід користувача для подальшої обробки.

## Стандартні операції мови Колібрі

### Таблиця операторів

| Оператор | Опис                 | Унарний правий | Унарний лівий | Бінарний | Цілі | Дробові | Рядок | Логічні |
|----------|----------------------|-------------|------------|--------|----------|--------|--------|---------|
| +        | Додавання            | Ні          | Так        | Так    | Так      | Так    | Так    | Ні      |
| -        | Віднімання/Негація   | Ні          | Так        | Так    | Так      | Так    | Ні     | Ні      |
| *        | Множення             | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| /        | Ділення              | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| %        | Модуль               | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |
| ++       | Інкремент            | Так         | Так        | Ні     | Так      | Ні     | Ні     | Ні      |
| --       | Декремент            | Так         | Так        | Ні     | Так      | Ні     | Ні     | Ні      |
| !        | Логічне/Бітове НІ    | Ні          | Так        | Ні     | Так      | Ні     | Ні     | Так     |
| &&       | Логічне І            | Ні          | Ні         | Так    | Ні       | Ні     | Ні     | Так     |
| \|\|     | Логічне АБО          | Ні          | Ні         | Так    | Ні       | Ні     | Ні     | Так     |
| ==       | Дорівнює             | Ні          | Ні         | Так    | Так      | Так    | Так    | Так     |
| !=       | Не дорівнює          | Ні          | Ні         | Так    | Так      | Так    | Так    | Так     |
| >        | Більше ніж           | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| <        | Менше ніж            | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| >=       | Більше дорівнює      | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| <=       | Менше дорівнює       | Ні          | Ні         | Так    | Так      | Так    | Ні     | Ні      |
| <<       | Зсув вліво           | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |
| >>       | Зсув вправо          | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |
| &        | Бітове І             | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |
| ^        | Бітове виключне АБО  | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |
| \|       | Бітове АБО           | Ні          | Ні         | Так    | Так      | Ні     | Ні     | Ні      |


### Таблиця пріоритетів операторів

| Рівень приорітету | Оператори            | Тип            |
|-------------------|----------------------|----------------|
| 1.                | `++`, `--`           | Унарний Лівий  |
| 2.                | `++`, `--`           | Унарний Правий |
| 3.                | `!`, `+`, `-`        | Унарний Лівий  |
| 4.                | `*`, `/`, `%`        | Бінарний       |
| 5.                | `+`, `-`             | Бінарний       |
| 6.                | `<<`, `>>`           | Бінарний       |
| 7.                | `<`, `>`, `<=`, `>=` | Бінарний       |
| 8.                | `==`, `!=`           | Бінарний       |
| 9.                | `&`                  | Бінарний       |
| 10.               | `^`                  | Бінарний       |
| 11.               | `\|`                 | Бінарний       |
| 12.               | `&&`                 | Бінарний       |
| 13.               | `\|\|`               | Бінарний       |

### Перетворення типів

У Колібрі сумісність типів є суворою; операції працюють тільки між змінними одного типу. Це часто призводить до необхідності приведення типів. Для цього у Kolibri передбачено спеціальний синтаксис: `змінна::тип`. 

#### Приклад

```kolibri
i = 4; // long
console.Write(i::string);
```

#### Інформація про стандартні перетворення типів:

- **З плаваючою комою в ціле число**: Обрізає числа після десяткової крапки.
- **До типу Bool**: Буде "істиною", якщо значення дорівнює 1 або "істина".
- **До меншого типу**: При перетворенні можуть бути втрачені дані, точність не гарантується.
- **Bool до інших типів**: Перетворюється в 1 або "true", якщо значення `true`, і в 0 або "false", якщо `false`.
- **Універсальний**: Будь-який стандартний тип може бути перетворений у будь-який інший стандартний тип.

## Оператори If-Else

Для новачків оператор `if-else` схожий на дорогу з розвилкою. Він допомагає програмі вирішити, яким шляхом рухатись, залежно від того, чи виконується певна умова. Якщо умова істинна, програма піде одним шляхом (`if`), а якщо ні, то іншим (`else`).

### Синтаксис 

1. **Один оператор**: Якщо ви використовуєте його для одного оператора, ви пишете ключове слово `if`, умову, а потім двокрапку. Після цього ви пишете оператор, який виконується, якщо умова істинна. **Примітка**: В операторі `else` двокрапка не ставиться.
    ```c#
    if деяка_умова: do_this();
    else do_that();
    ```
  
2. **Блок операторів**: Якщо вам потрібно виконати декілька операторів, ви використовуєте фігурні дужки, щоб згрупувати їх. 
    ```c#
    if деяка_умова {
        do_this();
        do_this_too();
    } else {
        do_that();
        і_таке();
    }
    ```

#### Приклади

- Простий оператор If-Else

    ```c#
    if x == 1: console.Write("x дорівнює 1");
    else console.Write("x не 1");
    ```
  
- **Якщо-Если з декількома умовами (Else If)**

    ```c#
    if x < 0 {
        console.Write("x від'ємне");
    } else if x > 0 {
        console.Write("x додатне");
    } else {
        console.Write("x дорівнює нулю");
    }
    ```

    або

    ```c#
    if x < 0: console.Write("x від'ємне");
    else if x > 0: console.Write("x додатне");
    else console.Write("x дорівнює нулю");
    ```
  
## Цикли та керуючі структури в Kolibri

Kolibri представляє свіжий підхід до циклів та умовних операторів. Розглянемо кожен з них, зосередившись на унікальному циклі `from` та його універсальності.

### Цикл `from`

Цикл `from` в Kolibri неймовірно гнучкий, здатний обробляти різноманітні умови та кроки. 

#### Синтаксис

```c#
i from <start> [to|until] <end> [step <step_size>] [do <action>]
```

#### Алгоритм

Ініціалізуємо `i` на `<start>`.

Для `<end>` типу `i`: 

> Якщо використовується `until`, виконати цикл, доки `i` є меншим за `<end>`. Якщо використовується `to`, цикл виконується, доки `i` є меншим або рівним `<end>`.

Для `<end>` типу `bool`: 

> Якщо використовується `until`, цикл виконується, доки `i` є рівним `true`. Якщо використовується `to`, цикл, поки `<end>` є рівним `false`.

Після кожної ітерації додавати до `i` інкремент `<step_size>`, якщо вказано.

Якщо присутній `do <action>`, виконати `<action>` на `i` на кожній ітерації циклу.

#### Приклади

```c#
i від 0 до 10 // Ітерації від 0 до 10 включно
i від 0 до 10 крок 2 // Перебирає від 0 до 9 з кроком 2
i від 0 до i > 4 // Ітерація до тих пір, поки i > 4 не стане хибним
i від 0 до i < 4 // Ітерація до тих пір, поки i < 4 не стане істинним
i from 0 to 10 do i.Do() // Виконує i.Do() для кожної ітерації від 0 до 10
```

### Цикл While

Цикл `while` в Колібрі виконує один і той самий блок коду до тих пір, поки задана умова є істинною.

**Синтаксис**:

```c#
while <умова>:
    // Одиничний оператор
```
або
```c#
while <умова> {
    // Кілька операторів
}
```

**Приклад**:
```c#
i = 0;
while i < 10 {
    console.Write(i);
    i++;
}
```

### Цикл While Until

Цикл `while until` є різновидом циклу, який також виконується до тих пір, поки його умова істинна. 

**Синтаксис**:

```c#
while until <умова>:
    // код
```

**Приклад**:

```c#
i = 0;
while until i == 10
{
    console.Write(i);
    i++;
}
```

### Цикл While To

Цикл `while to` виконується до тих пір, поки умова не стане істинною. Це корисно, коли ви хочете, щоб цикл виконався хоча б один раз.

**Синтаксис**:

```c#
while to <умова>:
    // код
```

**Приклад**:

```c#
i = 0;
while to i > 10:
    console.Write(++i);
```

### Блок From <span style="color:red">(в розробці)</span>

Блок `from` слугує механізмом умовного розгалуження. Він може порівнювати змінну з декількома можливими значеннями і виконувати відповідні блоки коду.

**Синтаксис**:

```c#
from i 
{ 
    значення1{}, 
    value2{} 
}
```

### Цикл From <span style="color:red">(в розробці)</span>

Цикл `from` працює подібно до циклу foreach, виконуючи блок коду для кожного елемента колекції.

**Синтаксис**:

```c#
i from j:
    console.WriteLine(i::string);
```

## Масиви у Колібрі <span style="color:red">(в розробці, але є динамічні, далі в туторіалі)</span>

### Що таке масив?

Масив - це список або колекція змінних з однаковими іменами та типами. Замість того, щоб оголошувати декілька змінних для зберігання пов'язаної інформації, ви можете просто створити масив. Це як мати кілька поштових скриньок за однією адресою, кожна з яких має свій унікальний номер. Ви можете покласти щось у певну поштову скриньку або дістати з неї, просто знаючи її номер. 

### Оголошення масивів

У Kolibri створення масиву - це простіше простого. Ви можете зробити це трьома основними способами:

1. `зміннаName:[тип; розмір];` 
   - Створюється порожній масив певного типу та розміру. 
2. `variableName:[initialValue; size];` 
   - Створює масив із заданим початковим значенням для всіх елементів.
3. `variableName = [value1, value2, value3];`
   - Одразу ініціалізує масив конкретними значеннями.

### Доступ до даних масиву

Щоб дістатися до вмісту ваших "поштових скриньок", ви використовуєте індекс, починаючи з нуля.

```
ім'яMасиву[індекс]
```

### Отримання розміру масиву

Якщо вам коли-небудь знадобиться дізнатися, скільки у вас 'поштових скриньок', використовуйте:

```c#
arrayName.Len
```

### Циклічний перегляд масиву

Хороші новини, ви можете використовувати цей чудовий цикл `from` і з масивами.

```c#
i from j:
    console.WriteLine(i::string)
```

### Багатовимірні масиви

Так, ви навіть можете мати масиви масивів, як велика стара сітка поштових скриньок. Вони бувають двох типів:

1. Нерівномірний масив:
    ```c#
    значення:[[тип]; розмір]
    ```
2. Прямокутний масив:
    ```c#
    value:[[тип; розмірБ]; розмірА]
    ```

## Функції у Колібрі

### Що таке функція?

Уявіть собі функцію як міні-програму всередині вашої основної програми. Це як чарівна скринька, яка бере щось, робить свої чари і іноді повертає щось назад. Ви можете використовувати цю чарівну скриньку знову і знову, де завгодно у вашій програмі. Це спосіб уникнути повторення одного і того ж коду знову і знову. 

### Створення функцій у Колібрі

У Колібрі створити функцію не складає особливих труднощів. У вас є різні варіанти синтаксису для її визначення:

1. **Типізовані параметри**
    ```c#
    FunctionName(param1:type1, param2:type2)
    ```
2. **Значення за замовчуванням**
    ```c#
    FunctionName(param1 = вираз1, param2 = вираз2)
    ```
3. **Шаблонний (без типів)**
    ```c#
    FunctionName(param1, param2)
    ```
    Цей варіант працює як шаблон, тобто ви можете передати будь-який тип і функція адаптується.
  
4. **Змішаний пакет**
    ```c#
    FunctionName(param1:type1, param2 = вираз2)
    ```
    Параметри з виразом завжди повинні бути в кінці.

### Тіло функції

Ваша функція може мати тіло з одного рядка:

```c#
Add(a, b) console.Write((a+b)::string);
```

Або багаторядковий блок:

```c#
Add(a, b) {
    console.Write((a+b)::string);
    console.Write("\n");
}
```

### Значення, що повертаються

Ваша функція також може повертати значення за допомогою символу `=>`:

```c#
Add(a, b) => a+b;
```

### Виклик функцій

Щоб використати вашу функцію, просто викличте її за назвою та надайте необхідні "інгредієнти":

```
Ім'я функції(вираз1, вираз2, вираз3);
```

## Покажчики та система керування ними у Колібрі

### Що таке покажчики?

Уявіть, що у вас в кімнаті стоїть коробка. Замість того, щоб ходити до неї кожного разу, коли вам щось потрібно, ви можете скористатися "мапою", яка безпосередньо вказує на цю коробку. Ця карта - це те, що ми називаємо "вказівником" у програмуванні. Він вказує на місце в пам'яті, де зберігаються ваші дані (скринька).

### Іменування (розіменування) та вказівка на (посилання)
  
- ** (`<змінна>`)** - це створення мапи вашої скриньки. Ви отримуєте розташування ваших даних у пам'яті.

- Розіменування проходить автоматично, і означає, що ви заглядаєте всередину вікна. Ви отримуєте фактичні дані, на які вказує вказівник.

### Синтаксис

1. **Створення вказівника**
    ```c#
    покажчик = <змінна>;
    ```
   
### Правила

1. **Нульові вказівники**: У Колібрі не може бути вказівника, який ні на що не вказує. Він завжди повинен мати місце призначення.
  
2. **Вказівник на вказівник**: Ви не можете мати вказівники, що вказують на інші вказівники, якщо тільки ви не працюєте з динамічними масивами (про це пізніше).

### Приклади

```c#
a = 7;
b = <a>;
c = <b>; // стає диктатором для а (далі по темі)
```

## Система керування вказівниками Колібрі - модель диктатури

### Основи

Ця модель по суті є способом керування вказівниками. Вона диктує, який вказівник отримує право керувати і змінювати змінну, на яку він вказує. Це все про контроль та підзвітність, що гарантує, що ви не зможете мати проблеми з видаленням та контролем пам'яті

### Терміни

- **Власник**: Оригінальний власник даних.
- **Узурпований**: Первісний власник, але з доступом лише для читання.
- **Диктатор**: Той, хто перехоплює доступ на запис у первісного власника.
- **Повалений**: Колишній диктатор без права на запис.
- **Посіпака**: Вторинний вказівник з доступом лише на читання.

### Приклади

**Єдиний диктатор**

```kolibri
a = 7; // власник
b = <a>; // `a` узурповано, `b` - диктатор-покажчик на a
```

**Повалення диктатора**

```kolibri
c = <b>; // `b` повалено, `c` - диктатор на `a`
```

**Множинні поплічники**

```kolibri
=d = <c>; // `d` - прихвостень, `c` - диктатор
```

### Умовний контекст

```kolibri
Boo() {
    a = 7;
    b = <a>;
    if a == 5 {
        c = <b>; // `b` тепер тільки для читання, `c` править
    } // c знищується, `b` знову править
}// b, a знищується;
```

### Обмеження

Ви не можете скидати або повертати іноземні диктатори всередині функції:

```kolibri
Boo(a:<long>) b = <a>; // Помилка: не можна перевизначати іноземця
Foo(a:<long>) => <a>; // Помилка: не можна повертати іноземця
```

### Динамічне володіння

```kolibri
a = 1;
b = 2;
c = <a>; // c є диктатором для a
c = <b>; // c - диктатор для b, a знову власник
```

## Контейнери даних у Колібрі

### Що таке контейнери даних?

Контейнери даних, або кастомні типи даних, - це міні-бази даних для зберігання декількох елементів даних в одному блоці. Вони дозволяють вам групувати різні поля та методи, які працюють з цими полями. Це як створення суперзмінної зі своїми власними підзмінними та функціями. Ідеально підходить для новачків, які не хочуть загубитися в морі змінних.

### Синтаксис створення контейнерів даних

Ви визначаєте контейнер даних за допомогою ключового слова `data`. Ось базовий синтаксис:

```
data Ім'я:
  поле1:тип;
  поле2:тип;
  MethodName(params) {}
```

### Ініціалізація даних у коді

Змінну даних можна ініціалізувати одним з двох способів:

1. Явна вказівка полів:  
  ```rust
  змінна:DataType(поле1:expr1, поле2:expr2);
  ```
  
2. Неявна ініціалізація з використанням позиційних аргументів:  
  ```rust
  змінна:DataType(expr1, expr2);
  ```

### Доступ до поля

Ви отримуєте доступ до поля всередині контейнера даних таким чином:

```rust
а = змінна.поле;

змінна.поле = 5;
```

### Доступ до методів

Ви отримуєте доступ до методу всередині контейнера даних таким чином:

```
змінна.Ім'яМетоду(params);
```

### Реальний приклад

Створимо контейнер даних `Person` з методом `greet`.

```rust
Vitalii:Person("Vitalii", 18);
Vitalii.greet(); // Виведе: "Привіт, мене звати Віталій і мені 18 років".

data Person:
  name:string;
  age:int;
  Greet() 
    console.Write("Привіт, мене звати " + name + " і мені " + (age)::string + " років.");
```

### Залежні поля

Ви можете зробити одне поле залежним від іншого під час ініціалізації. Ось приклад з використанням контейнера даних `Square`:

```rust
a:Square(1);
console.Write(a.y::string); // Виведення: "1"

date Square:
  x:int
  y = x;
```

## Диктатура в контейнерах даних

### Як це працює

У Колібрі концепція диктатури також застосовується до контейнерів даних, але з невеликими уточненями. На відміну від звичайних диктаторів, що оголошуються в контексті коду, змінюваність (або незмінність) диктатора в контейнері даних визначається під час створення об'єкта даних і залишається фіксованою.

### Неправильний приклад

У наступному прикладі ми не можемо зробити `c` диктатором для `a.value`, оскільки `a` є незмінним у контексті даних:

```kolibri
b = 7;
a:Data(value: <b>);
c = a.value; // Помилка: не можна перевизначити `a`, тому що `a` захищено даними

data Data:
  value:<long>;
```

### Правильний приклад

Тут `a.value` є незмінюваним (позначається символом `=` перед визначенням поля), і воно може виступати в ролі приспішника для `b`. Тоді `c` також може стати посіпакою для `b`.

```kolibri
b = 7;
a:Data(value: <b>); // Правильно: b - власник, a.value - посіпака
c = <a.value>; // Коректно: b - власник, a.value - посіпака, c також посіпака

дані Data:
  =value:<long>;
```

### Управління ресурсами

Цей механізм допомагає у правильному управлінні ресурсами. Якщо контейнер даних, який містить диктатор, знищується, диктатор також знищується автоматично. Це може допомогти запобігти витоку ресурсів і зробити ваш код більш ефективним.

## Динамічні масиви у Колібрі

### Що це таке?

Динамічні масиви в Колібрі - це, по суті, вказівники на суміжні блоки пам'яті, розмір яких можна задавати під час виконання програми. Так, це, по суті, вказівник, але з деякими додатковими функціональними можливостями, щоб полегшити роботу з ним.

### Ініціалізація

Динамічний масив можна ініціалізувати декількома способами:

- Задаванням типу та розміру: `var:<type; size>;`
- Вказівкою початкового значення та розміру: `var:<initVal; size>;`
- Безпосереднім присвоюванням значень: `var = <exp1, exp2, exp3>;`

### Доступ до даних та знаходження довжини

Доступ до елементів масиву здійснюється з допомогою нульової індексації: `array[index]`.

Для отримання довжини масиву використовується функція `array.Len`.

### Циклічний прохід по масиву <span style="color:red">(в розробці)</span>

Ви можете циклічно переглядати масив, використовуючи конструкції на кшталт:

```kolibri
i from j:
    console.WriteLine(i::string);
```

### Покажчики, але не зовсім

Незважаючи на те, що динамічні масиви по суті є вказівниками, ви не можете розіменовувати їх, як ви могли б очікувати. Це зроблено для безпеки типу та зручності читання, напевно.

### Багатовимірні масиви

Ви можете створювати багатовимірні масиви за допомогою цього синтаксису: `значення:<<тип>; розмір>;`. Якщо ви хочете мати прямокутні масиви, ви можете зробити це за допомогою `value:<<type; sizeB>; sizeA>;`.

### Динамічні масиви проти звичайних масивів

- Концепція диктатури застосовується до динамічних масивів. Ви можете мати власників, поплічників та диктаторів для вашого динамічного масиву.
- Коли ви передаєте динамічний масив у функцію, він передається як вказівник; звичайні масиви передаються за значенням.
- Регулярні масиви в Колібрі мають більше функцій і можуть динамічно змінюватися.

### Аналогія з C++

Для тих, хто знайомий з C++, динамічний масив у Колібрі схожий на сирий динамічний масив у C++, а звичайний масив більше схожий на `vector`.

## Функції як вказівники у Колібрі

### Вступ

У багатьох мовах функції часто розглядаються як "першокласні громадяни". Це означає, що їх можна присвоювати змінним, передавати, повертати з інших функцій тощо. Kolibri дотримується тієї ж філософії. Тут ви можете зберігати вказівники на функції у спеціальних типах.

### Синтаксис

Для визначення типу вказівника на функцію використовується наступний синтаксис:

```
param1:param2:returnType
```

Щоб присвоїти покажчик на функцію, використовується ім'я функції без круглих дужок:

```
функція
```

### Обмеження

Отримавши вказівник на функцію, ви можете викликати функцію тільки через нього. Ви не можете змінити функцію або розіменовувати вказівник. Ось приклад:

```c++
Boo(Add, 5, 6);
Boo(op:long:long:long, a:long, b:long) console.Write(op(a, b)::string);
Add(a:long, b:long) => a + b;
```

### Типи-void

Якщо функція не отримує параметрів або нічого не повертає, використовується тип `void`. Наприклад, так:

```c++
Boo(Do);
Boo(f:void:void) f();
Do() console.Write("Hello, World!");
```

### Шаблони

При роботі з шаблонами функцій потрібно вказувати типи за допомогою кутових дужок `<>`. Наприклад:

```c++
Boo(Add<long, long>, 5, 6);
Boo(op:long:long:long, a:long, b:long) console.Write(op(a, b)::string);
Add(a, b) => a + b;
```

## Простори імен у Колібрі

### Вступ

Простори імен є важливою особливістю багатьох мов програмування, що допомагає організувати код, керувати областю видимості та запобігати колізіям імен. У Колібрі для визначення простору імен використовується ключове слово `space`. Це дає вам можливість тримати пов'язані функціональні можливості разом під однією парасолькою, що сприяє створенню більш чистого та зручного для супроводу коду.

### Синтаксис

Оголосити простір імен у Kolibri дуже просто:

```kolibri
space spaceName:
```

Щоб викликати функцію всередині простору імен:

```kolibri
spaceName.FunctionName();
```

Якщо ви використовуєте ключове слово `use` для імпорту простору імен, то ви можете викликати функцію безпосередньо:

```kolibri
use:spaceName;
FunctionName();
```

### Вкладені простори імен

Простори імен можна вкладати за допомогою нотації `.`. Наприклад

```kolibri
space name1.name2:
Foo();
```

Якщо ви використовуєте `use:name1;`, ви можете викликати вкладену функцію таким чином:

```kolibri
name2.Foo();
```

Але ви не можете викликати її безпосередньо як `Foo()`.

### Функції у просторах імен

Щоб визначити функцію в межах простору імен без явного виведення цілого блоку простору, ви можете використати наступний синтаксис:

```kolibri
spaceName.Boo(){}
```

Наприклад:

```kolibri
use:test;
Hello();
test.Hello() console.Write("Hello, World!");
```

Це еквівалентно

```kolibri
use:test;
Hello();
space test:
Hello() console.Write("Hello, World!");
```
